#include<iostream>
#include<Eigen/Dense>
#include<string>
#include<vector>
#include<stdlib.h>
#include "system.h"
#include "analysis.h"
#include "coshfunc.h"
#include "emulator.h"
#include "mcmc.h"

int main(int argc, char* argv[]){
  //Check that usage is proper: enter the model output to use
  if(argc != 3)
    {
      printf("Usage: ./main start end\n");
      return 1;
    }
  int action=1;
  /*************************************
   *    Write Parameters files        *
  *************************************/
  //vector to store parameter names from RangeFile
  //foldername = model BF location
  //writefilename = paramfile name, should default to parameters.dat
  //rangename = rangefile for parameters and paramnames to LCHsample for model run
  std::string 
    foldername="model_output",
    writefilename="parameters.dat",
    rangename=foldername+"/parameter_priors.dat",
    infilename=foldername+"/moments_parameters.dat",
    delimiter=" ",
    gabname=foldername+"/gabfunctions.dat";
  //start, finish for model runs to use
  int
    start=atoi(argv[1]),
    finish=atoi(argv[2]),
    ab=4;
  Eigen::MatrixXd Parameters;

  WriteParameterFiles(rangename, foldername, writefilename, delimiter,
		      start, finish, ab, 
		      Parameters);
  WriteFile(infilename,Parameters,delimiter);

  Eigen::MatrixXd paramScaled;
  Eigen::VectorXd paramMean, paramStd;
  //printf("Scaling Parameters --> N(0,1)\n");
  //ScaleMatrixColumns(Parameters, paramMean, paramStd, paramScaled);
  //Eigen::MatrixXd
  //  paramM = Eigen::MatrixXd(1,Parameters.cols()),
  //  paramS = Eigen::MatrixXd(1,Parameters.cols());
  //paramM.row(0) = paramMean;
  //paramS.row(0) = paramStd;
  //WriteFile("paramMean.dat",paramM," ");
  //WriteFile("paramStd.dat",paramS," ");

  /*************************************
   *    Construct gab functions       *
  *************************************/
  //LoadFile(infilename,Parameters,delimiter);
  WriteGABFunctions(gabname,Parameters,delimiter,ab);

  /*************************************
   *   Run Model for output           *
  *************************************/
  //Run Scott's program
  //system("cd ..;pwd; cd src/");
  

  /*************************************
   *   Load Data for analysis         *
  *************************************/
  //Model BF filenames
  std::vector<std::string> modelfilenames={"I211_J211.dat",
					   "I2212_J2212.dat",
					   "I321_J2212.dat",
					   "I321_J321.dat"};
  //EXP quark filenames
  std::vector<std::string> expfilenames={"star_pipi.dat",
					 "star_ppbar.dat",
					 "star_pK.dat",
					 "star_KK.dat"};
  //Number of model && exp files
  //data column to be selected from model/exp files
  std::vector<Eigen::MatrixXd> 
    ModelMatrix,
    ExpMatrix;
  Eigen::VectorXd
    modeldy,
    expdy;

  LoadMEDataFiles(modelfilenames, expfilenames,
		     ModelMatrix, ExpMatrix,
		     modeldy, expdy,
		     foldername, delimiter,
		     start, finish);
  Eigen::MatrixXd holder;
  for(int i=0;i<4;i++){
    AddOnesColumn(ModelMatrix[i],holder);
    holder.col(0) = modeldy;
    WriteFile(foldername+"/"+modelfilenames[i],holder,delimiter);
  }

  
  /*************************************
   *   Conduct model analysis         *
  *************************************/
  Eigen::MatrixXd
    ModelObs,
    ExpObs;
  //Ratio of ExpObs to Error, e.g. 0.1 --> Error=0.1*ExpObs
  double er=0.1;
  Eigen::VectorXd
    Error,
    Mean,
    EigenValues;
  Eigen::MatrixXd
    ModelTilde,
    ExpTilde,
    Covariance,
    EigenVectors,
    ModelZ,
    ExpZ;
  
  //Calculate Model & Exp Moments, calc Error
  MatrixMoments(ModelMatrix,modeldy,ModelObs);
  MatrixMoments(ExpMatrix,expdy,ExpObs);
  Error = er*ExpObs.col(0);

  //Calculate y-tilde for Model & Exp
  AverageRows(Mean,ModelObs);
  TildeFunction(ModelTilde,Mean,Error,ModelObs);
  TildeFunction(ExpTilde,Mean,Error,ExpObs);

  //Calculate Covariance of ModelTilde and related eigenvectors
  CovarianceFunction(Covariance,ModelTilde);
  EigenSolve(EigenValues,EigenVectors,Covariance);
  EigenSort(EigenValues,EigenVectors);

  //Calculate Principle Components of y-tilde
  ModelZ = ModelTilde.transpose()*EigenVectors;
  ExpZ = ExpTilde.transpose()*EigenVectors;


  int 
    parameters = Parameters.cols(),
    observables = ModelZ.cols();
  Eigen::MatrixXd EigenV=Eigen::MatrixXd::Zero(1,observables);

  //Write out PC
  EigenV.row(0) = EigenValues;
  //WriteFile(foldername+"/expz.dat",ExpZ," ");
  //WriteFile(foldername+"/modelz.dat",ModelZ," ");
  WriteFile(foldername+"/eigvec.dat",EigenVectors," ");
  WriteFile(foldername+"/eigval.dat",EigenV," ");

  //std::cout << "Parameters:\n" << Parameters << std::endl;  
  //std::cout << "ModelObs:\n" << ModelObs << std::endl;
  //std::cout << "ExpObs:\n" << ExpObs << std::endl;
  //std::cout << "Error:\n" << Error << std::endl;
  //std::cout << "Mean:\n" << Mean << std::endl;
  //std::cout << "ModelTilde:\n" << ModelTilde << std::endl;
  //std::cout << "ExpTilde:\n" << ExpTilde << std::endl;
  //std::cout << "Covariance:\n" << Covariance << std::endl;
  std::cout << "EigenValues:\n" << EigenValues.transpose() << std::endl;
  //std::cout << "EV:\n" << EigenVectors << std::endl;
  std::cout << "----------------" << std::endl;
  //std::cout << "ModelZ:\n" << ModelZ << std::endl;
  //AverageColumns(Mean,ModelZ);
  //std::cout << "ModelZMean:\n" << Mean.transpose() << std::endl;
  std::cout << "ExpZ:\n" << ExpZ << std::endl;


  /*************************************
   *   Plot ModelZ w/ Params          *
  *************************************/
  Eigen::MatrixXd 
    plot(finish-start,parameters+observables);

  plot.block(0,0,finish-start,parameters) = Parameters;
  plot.block(0,parameters,finish-start,observables) = ModelZ;
  WriteFile(foldername+"/trainplot.dat",plot," ");
  //plot.block(0,0,finish-start,parameters) = paramScaled;
  //WriteFile("trainplotScaled.dat",plot," ");

  /*************************************
   *   Conduct MCMC Analysis          *
  *************************************/
  if(action==1)
    {
  int 
    test=finish-start;
  std::vector<std::string> 
    paramNames;
  Eigen::MatrixXd 
    Hyperparameters,
    outMatrix(test,parameters+observables),
    range,
    Beta;
  Eigen::VectorXd
    Width(parameters),
    WidthScaled(parameters);

  //Load Hyperparameters
  LoadFile("hyperparameters.dat",Hyperparameters," ");
  //Load Range File
  LoadParamFile(rangename,paramNames,range,delimiter);
  //Create Widths
  //printf("Scaling range.\n");
  //Eigen::MatrixXd rangeScaled;
  //TildeFunction(rangeScaled, paramMean, paramStd, range);

  //for(int i=0;i<parameters;i++)
  //  {
  //    WidthScaled(i) = (rangeScaled(i,1) - rangeScaled(i,0))/75.0;
  //  }

  for(int i=0;i<parameters;i++)
    {
      Width(i) = (range(i,1) - range(i,0))/75.0;
    }

  //Create & Write Beta matrix
  RemoveColumn(ModelZ,0);
  RemoveRow(Hyperparameters,0);

  linearRegressionLeastSquares(ModelZ,Parameters,Beta);
  //WriteFile("beta.dat",Beta," ");
  int row=5;
  ExpZ = ModelZ.row(row);
  std::cout << row << " row: " << Parameters.row(row) << " " << ExpZ << std::endl;
  Eigen::MatrixXd Goal = Eigen::MatrixXd::Zero(1,parameters+observables);
  Goal.block(0,0,1,parameters) = Parameters.row(row);
  Goal.block(0,parameters,1,observables) = ExpZ;
  WriteFile(foldername+"/target.dat",Goal,delimiter);

  emulator emulation(Parameters, Hyperparameters, Beta);

  MCMC mcmc(ExpZ,range,Width,true);
  mcmc.setPosition();
  int Samples=10000;

  Eigen::MatrixXd History;
  mcmc.Run(Samples, History, emulation, ModelZ);
  Eigen::MatrixXd 
    trace = History.block(0,0,Samples,parameters),
    ntrace,
    posterior;
  std::string posteriorname = foldername+"/posterior.dat";

  Extract5(ntrace,trace);
  ExtractOnly20(posterior,ntrace);
  printf("Writing posterior.dat files...\n");
  WriteFile(posteriorname,posterior,delimiter);
  gabname = foldername + "/posterior_gabfunctions.dat";
  WriteGABFunctions(gabname,posterior,delimiter,ab);
  /*
  posteriorname = "posterior.dat";
  for(int i=0;i<posterior.rows();i++)
    {
      for(int j=0;j<posterior.cols();j++)
	{
	  posterior(i,j) = posterior(i,j)*paramStd(j) + paramMean(j);
	}
    }
  WriteFile(posteriorname,posterior,delimiter);
*/
  WriteCSVFile(foldername+"/mcmctrace.csv",paramNames,ntrace,",");

}


  /*************************************
   *   Conduct Fit Analysis           *
  *************************************/
  if(action==2)
    {
  observables=2;
  int 
    test=finish-start;
  std::vector<std::string> 
    paramNames;
  Eigen::MatrixXd 
    Hyperparameters,
    range,
    Beta,
    testY,
    print = Eigen::MatrixXd::Zero(finish-start, parameters+observables*4);

  Eigen::VectorXd Width(parameters);
  //Load Hyperparameters
  LoadFile("hyperparameters.dat",Hyperparameters," ");
  //Load Range File
  LoadParamFile(rangename,paramNames,range,delimiter);
  //printf("Scaling range.\n");
  //Eigen::MatrixXd rangeScaled;
  //TildeFunction(rangeScaled, paramMean, paramStd, range);

  //Create & Write Beta matrix
  int rows = finish-start;
  rows=10;
  for(int row=0;row<rows;row++){
    //Eigen::MatrixXd testX = Parameters.row(row);
    Eigen::MatrixXd testX = paramScaled.row(row);

    //Eigen::MatrixXd testY_ = ModelZ.row(row),
    // PM = Parameters,
    // MZ = ModelZ;
    Eigen::MatrixXd testY_ = ModelZ.block(row,1,1,observables),
      //PM = Parameters,
      PM = paramScaled,
      MZ = ModelZ.block(0,1,ModelZ.rows(),observables);

    RemoveRow(PM,row);
    RemoveRow(MZ,row);


    linearRegressionLeastSquares(MZ,PM,Beta);

    std::cout << std::endl;
    std::cout << "row " << row << std::endl;
    std::cout << "testX : " << testX << std::endl;
    std::cout << "ModelY: " << testY_ << std::endl;
    print.block(row,0,1,parameters) = testX;

    Eigen::MatrixXd Fit;
    emulator emulation(PM, Hyperparameters, Beta);
    emulation.Emulate(testX, MZ, testY);
    std::cout << "RtestY:" << testY << std::endl;
    ComputeFit(testY_,testY,Fit);
    std::cout << "Fit   :" << Fit << std::endl;
    print.block(row,parameters,1,observables) = testY;
    print.block(row,parameters+observables,1,observables) = Fit.block(0,1,1,observables);    

    emulation.Emulate_NR(testX, MZ, testY);
    std::cout << "testY :" << testY << std::endl;
    ComputeFit(testY_,testY,Fit);
    std::cout << "Fit   :" << Fit << std::endl << std::endl;
    print.block(row,parameters,1,observables) = testY;
    print.block(row,parameters+observables,1,observables) = Fit.block(0,1,1,observables);    
  }
  WriteFile(foldername+"/fit.dat",print,delimiter);
}

  return 0;
}
